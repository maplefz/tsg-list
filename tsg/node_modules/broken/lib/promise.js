// Generated by CoffeeScript 1.12.4
var Promise, STATE_FULFILLED, STATE_PENDING, STATE_REJECTED, _undefined, _undefinedString, rejectClient, resolveClient, soon;

Promise = function(func) {
  var me;
  if (func) {
    me = this;
    func(function(arg) {
      me.resolve(arg);
    }, function(arg) {
      me.reject(arg);
    });
  }
};

resolveClient = function(c, arg) {
  var err, yret;
  if (typeof c.y === 'function') {
    try {
      yret = c.y.call(_undefined, arg);
      c.p.resolve(yret);
    } catch (error1) {
      err = error1;
      c.p.reject(err);
    }
  } else {
    c.p.resolve(arg);
  }
};

rejectClient = function(c, reason) {
  var err, yret;
  if (typeof c.n === 'function') {
    try {
      yret = c.n.call(_undefined, reason);
      c.p.resolve(yret);
    } catch (error1) {
      err = error1;
      c.p.reject(err);
    }
  } else {
    c.p.reject(reason);
  }
};

STATE_PENDING = void 0;

STATE_FULFILLED = 'fulfilled';

STATE_REJECTED = 'rejected';

_undefined = void 0;

_undefinedString = 'undefined';

soon = (function() {
  var bufferSize, callQueue, cqYield, fq, fqStart;
  fq = [];
  fqStart = 0;
  bufferSize = 1024;
  cqYield = (function() {
    var dd, mo;
    if (typeof MutationObserver !== _undefinedString) {
      dd = document.createElement('div');
      mo = new MutationObserver(callQueue);
      mo.observe(dd, {
        attributes: true
      });
      return function() {
        dd.setAttribute('a', 0);
      };
    }
    if (typeof setImmediate !== _undefinedString) {
      return function() {
        setImmediate(callQueue);
      };
    }
    return function() {
      setTimeout(callQueue, 0);
    };
  })();
  callQueue = function() {
    var err;
    while (fq.length - fqStart) {
      try {
        fq[fqStart]();
      } catch (error1) {
        err = error1;
        if (global.console) {
          global.console.error(err);
        }
      }
      fq[fqStart++] = _undefined;
      if (fqStart === bufferSize) {
        fq.splice(0, bufferSize);
        fqStart = 0;
      }
    }
  };
  return function(fn) {
    fq.push(fn);
    if (fq.length - fqStart === 1) {
      cqYield();
    }
  };
})();

Promise.prototype.resolve = function(value) {
  var e, first, me, next;
  if (this.state !== STATE_PENDING) {
    return;
  }
  if (value === this) {
    return this.reject(new TypeError('Attempt to resolve promise with self'));
  }
  me = this;
  if (value && (typeof value === 'function' || typeof value === 'object')) {
    try {
      first = true;
      next = value.then;
      if (typeof next === 'function') {
        next.call(value, (function(ra) {
          if (first) {
            first = false;
            me.resolve(ra);
          }
        }), function(rr) {
          if (first) {
            first = false;
            me.reject(rr);
          }
        });
        return;
      }
    } catch (error1) {
      e = error1;
      if (first) {
        this.reject(e);
      }
      return;
    }
  }
  this.state = STATE_FULFILLED;
  this.v = value;
  if (me.c) {
    soon(function() {
      var l, n;
      n = 0;
      l = me.c.length;
      while (n < l) {
        resolveClient(me.c[n], value);
        n++;
      }
    });
  }
};

Promise.prototype.reject = function(reason) {
  var clients;
  if (this.state !== STATE_PENDING) {
    return;
  }
  this.state = STATE_REJECTED;
  this.v = reason;
  clients = this.c;
  if (clients) {
    soon(function() {
      var l, n;
      n = 0;
      l = clients.length;
      while (n < l) {
        rejectClient(clients[n], reason);
        n++;
      }
    });
  } else if (!Promise.suppressUncaughtRejectionError && global.console) {
    global.console.log('You upset Promise. Please catch rejections: ', reason, reason ? reason.stack : null);
  }
};

Promise.prototype.then = function(onF, onR) {
  var a, client, p, s;
  p = new Promise;
  client = {
    y: onF,
    n: onR,
    p: p
  };
  if (this.state === STATE_PENDING) {
    if (this.c) {
      this.c.push(client);
    } else {
      this.c = [client];
    }
  } else {
    s = this.state;
    a = this.v;
    soon(function() {
      if (s === STATE_FULFILLED) {
        resolveClient(client, a);
      } else {
        rejectClient(client, a);
      }
    });
  }
  return p;
};

Promise.prototype["catch"] = function(cfn) {
  return this.then(null, cfn);
};

Promise.prototype["finally"] = function(cfn) {
  return this.then(cfn, cfn);
};

Promise.prototype.timeout = function(ms, timeoutMsg) {
  var me;
  timeoutMsg = timeoutMsg || 'Timeout';
  me = this;
  return new Promise(function(resolve, reject) {
    setTimeout((function() {
      reject(Error(timeoutMsg));
    }), ms);
    me.then((function(v) {
      resolve(v);
    }), function(er) {
      reject(er);
    });
  });
};

Promise.prototype.callback = function(cb) {
  if (typeof cb === 'function') {
    this.then(function(value) {
      return cb(null, value);
    });
    this["catch"](function(error) {
      return cb(error, null);
    });
  }
  return this;
};

Promise.resolve = function(val) {
  var z;
  z = new Promise;
  z.resolve(val);
  return z;
};

Promise.reject = function(err) {
  var z;
  z = new Promise;
  z.reject(err);
  return z;
};

Promise.all = function(pa) {
  var rc, results, retP, rp, x;
  results = [];
  rc = 0;
  retP = new Promise;
  rp = function(p, i) {
    if (!p || typeof p.then !== 'function') {
      p = Promise.resolve(p);
    }
    p.then((function(yv) {
      results[i] = yv;
      rc++;
      if (rc === pa.length) {
        retP.resolve(results);
      }
    }), function(nv) {
      retP.reject(nv);
    });
  };
  x = 0;
  while (x < pa.length) {
    rp(pa[x], x);
    x++;
  }
  if (!pa.length) {
    retP.resolve(results);
  }
  return retP;
};

Promise.reflect = function(promise) {
  return new Promise(function(resolve, reject) {
    return promise.then(function(value) {
      return resolve(new PromiseInspection({
        state: 'fulfilled',
        value: value
      }));
    })["catch"](function(err) {
      return resolve(new PromiseInspection({
        state: 'rejected',
        reason: err
      }));
    });
  });
};

Promise.settle = function(promises) {
  return Promise.all(promises.map(Promise.reflect));
};

export default Promise;

//# sourceMappingURL=promise.js.map
